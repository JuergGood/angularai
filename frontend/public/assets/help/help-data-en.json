{
  "readme": "<h1 id=\"angularai-application\">AngularAI Application</h1>\n<p>This is a full-stack application with a Spring Boot backend and an Angular frontend.</p>\n<h2 id=\"prerequisites\">Prerequisites</h2>\n<ul>\n<li><a href=\"https://www.docker.com/get-started\">Docker</a></li>\n<li><a href=\"https://docs.docker.com/compose/install/\">Docker Compose</a></li>\n</ul>\n<h2 id=\"running-with-docker\">Running with Docker</h2>\n<p>To run the entire application using Docker Compose, navigate to the root directory and run:</p>\n<pre><code class=\"language-bash\">docker compose up --build\n</code></pre>\n<p>The application will be available at:\n- Frontend: <a href=\"http://localhost\">http://localhost</a>\n- Backend API: <a href=\"http://localhost:8080/api\">http://localhost:8080/api</a>\n- H2 Console: <a href=\"http://localhost:8080/h2-console\">http://localhost:8080/h2-console</a> (JDBC URL: <code>jdbc:h2:mem:testdb</code>)</p>\n<h2 id=\"deployment-scripts\">Deployment Scripts</h2>\n<p>Scripts are available in the <code>scripts/</code> folder for common deployment tasks (PowerShell and Windows CMD):</p>\n<ul>\n<li><strong>Local Docker Deployment</strong>: <code>.\\scripts\\deploy-local.ps1</code> or <code>.\\scripts\\deploy-local.bat</code></li>\n<li>Runs <code>docker compose up --build -d</code> to start the application locally in the background.</li>\n<li><strong>AWS Deployment</strong>: <code>.\\scripts\\deploy-aws.ps1</code> or <code>.\\scripts\\deploy-aws.bat</code></li>\n<li>Authenticates with AWS ECR, builds, tags, and pushes frontend and backend images, and forces a new deployment on ECS services.</li>\n</ul>\n<h2 id=\"project-structure\">Project Structure</h2>\n<ul>\n<li><code>backend/</code>: Spring Boot application.</li>\n<li><code>frontend/</code>: Angular application.</li>\n<li><code>android/</code>: Android Jetpack Compose application.</li>\n<li><code>docker-compose.yml</code>: Orchestration for both services.</li>\n</ul>\n<h2 id=\"development\">Development</h2>\n<h3 id=\"backend\">Backend</h3>\n<p>Navigate to <code>backend/</code> and run <code>./mvnw spring-boot:run</code>.</p>\n<h3 id=\"frontend-web\">Frontend (Web)</h3>\n<p>Navigate to <code>frontend/</code> and run <code>npm install</code> and then <code>npm start</code>.\nThe Angular development server is configured to proxy <code>/api</code> requests to <code>http://localhost:8080</code>. Ensure the backend is running.</p>\n<h2 id=\"documentation\">Documentation</h2>\n<ul>\n<li><a href=\"doc/userguide/user-guide.md\">User Guide</a></li>\n<li><a href=\"doc/userguide/admin-guide.md\">Admin Guide</a></li>\n<li><a href=\"doc/userguide/faq.md\">FAQ</a></li>\n<li><a href=\"scripts/md_to_confluence.py\">Confluence Export Script</a></li>\n<li><a href=\"doc/ai/android/android-build-instructions.md\">Android Build Instructions</a></li>\n<li><a href=\"doc/ai/aws/aws_setup.md\">AWS Setup and Infrastructure</a></li>\n<li><a href=\"doc/ai/backend/postgres_setup.md\">PostgreSQL Setup</a></li>\n<li><a href=\"doc/ai/aws/aws_fargate_config.md\">ECS Fargate Configuration</a></li>\n<li><a href=\"doc/ai/aws/aws_create_target_group.md\">Creating a Backend Target Group</a></li>\n<li><a href=\"doc/ai/aws/aws_alb_troubleshooting.md\">ALB and Connectivity Troubleshooting</a></li>\n<li><a href=\"doc/ai/aws/aws_ecs_push_instructions.md\">Pushing Images to Amazon ECR</a></li>\n</ul>",
  "user-guide": "<h1 id=\"user-guide\">User Guide</h1>\n<p>Welcome to the AngularAI User Guide. This document provides instructions on how to use the frontend application features.</p>\n<h2 id=\"table-of-contents\">Table of Contents</h2>\n<ol>\n<li><a href=\"#getting-started\">Getting Started</a></li>\n<li><a href=\"#dashboard\">Dashboard</a></li>\n<li><a href=\"#task-management\">Task Management</a></li>\n<li><a href=\"#user-profile\">User Profile</a></li>\n<li><a href=\"#logout\">Logout</a></li>\n</ol>\n<h2 id=\"getting-started\">Getting Started</h2>\n<p>To access the application, navigate to the frontend URL (typically <code>http://localhost</code>). You will be prompted to log in. If you don't have an account, you can register a new one.</p>\n<h3 id=\"login\">Login</h3>\n<p>Enter your username and password to access your account.</p>\n<h3 id=\"registration\">Registration</h3>\n<p>If you are a new user, click on the \"Register\" link. Provide your first name, last name, desired login, email address, and password.</p>\n<h2 id=\"dashboard\">Dashboard</h2>\n<p>The Dashboard provides an overview of your activities and the system status:\n- <strong>Summary Cards</strong>: Quick stats on Open Tasks, Active Users, Completed Tasks, and Today's Logs.\n- <strong>Task Overview</strong>: A visual distribution of tasks by status (Open, In Progress, Completed).\n- <strong>Recent Activity</strong>: A list of the latest actions performed in the system.\n- <strong>Priority Tasks</strong>: A list of high-priority tasks that need your attention.</p>\n<h2 id=\"task-management\">Task Management</h2>\n<p>The Task Management page allows you to organize your work:\n- <strong>Add Task</strong>: Click the \"Add Task\" button to create a new task. You can specify a title, description, due date, priority, and status.\n- <strong>Filter and Sort</strong>: Filter tasks by status (Open, In Progress, Completed) or reset sorting to view them by priority.\n- <strong>Edit Task</strong>: Click the edit icon on a task card to modify its details.\n- <strong>Delete Task</strong>: Click the delete icon to remove a task.\n- <strong>Drag and Drop</strong>: You can reorder tasks by dragging them using the handle (available when not filtering).</p>\n<h2 id=\"user-profile\">User Profile</h2>\n<p>In the Profile section, you can view your personal details, including your name, email, and assigned role.</p>\n<h2 id=\"logout\">Logout</h2>\n<p>To securely leave the application, click the \"Logout\" button in the side navigation menu.</p>",
  "admin-guide": "<h1 id=\"admin-guide\">Admin Guide</h1>\n<p>This guide is intended for system administrators of the AngularAI application. Administrators have access to additional features for user management and system monitoring.</p>\n<h2 id=\"table-of-contents\">Table of Contents</h2>\n<ol>\n<li><a href=\"#user-administration\">User Administration</a></li>\n<li><a href=\"#system-logs\">System Logs</a></li>\n<li><a href=\"#roles-and-permissions\">Roles and Permissions</a></li>\n</ol>\n<h2 id=\"user-administration\">User Administration</h2>\n<p>The User Administration page allows you to manage all users in the system:\n- <strong>List Users</strong>: View a list of all registered users, including their login name, full name, email, and role.\n- <strong>Add User</strong>: Create a new user account manually by providing their personal details and assigning a role.\n- <strong>Edit User</strong>: Modify the details of an existing user. Note that you cannot change the login name once a user is created.\n- <strong>Delete User</strong>: Remove a user from the system. You cannot delete your own account.\n- <strong>View User (Read-only)</strong>: Users with the <code>ROLE_ADMIN_READ</code> role can view user details but cannot make changes.</p>\n<h2 id=\"system-logs\">System Logs</h2>\n<p>The System Logs page provides an audit trail of actions performed within the application:\n- <strong>Audit Trail</strong>: View logs including timestamp, user login, action performed, and additional details.\n- <strong>Filtering</strong>: Filter logs by action type (Login, Tasks, User Admin) and date range.\n- <strong>Sorting</strong>: Sort logs by timestamp.\n- <strong>Paging</strong>: Navigate through large sets of logs using the paginator.\n- <strong>Clear Logs</strong>: Administrators with full write access can clear all logs using the \"Clear All Logs\" button.</p>\n<h2 id=\"roles-and-permissions\">Roles and Permissions</h2>\n<p>The application uses the following roles to control access:\n- <strong>ROLE_USER</strong>: Standard user access. Can manage their own tasks and view their profile.\n- <strong>ROLE_ADMIN</strong>: Full administrative access. Can manage users, view all logs, and perform system-wide actions.\n- <strong>ROLE_ADMIN_READ</strong>: Read-only administrative access. Can view user lists and logs but cannot perform modifications or deletions.</p>",
  "faq": "<h1 id=\"frequently-asked-questions-faq\">Frequently Asked Questions (FAQ)</h1>\n<h2 id=\"general\">General</h2>\n<h3 id=\"q-what-is-angularai\">Q: What is AngularAI?</h3>\n<p>A: AngularAI is a task management application featuring a modern Angular frontend, a Spring Boot backend, and an Android mobile app.</p>\n<h3 id=\"q-how-do-i-get-started\">Q: How do I get started?</h3>\n<p>A: Register for an account, log in, and start creating tasks on the Task Management page.</p>\n<h2 id=\"accounts-and-security\">Accounts and Security</h2>\n<h3 id=\"q-i-forgot-my-password-how-can-i-reset-it\">Q: I forgot my password. How can I reset it?</h3>\n<p>A: Currently, password reset must be handled by an administrator. Please contact your system administrator.</p>\n<h3 id=\"q-can-i-change-my-role\">Q: Can I change my role?</h3>\n<p>A: User roles can only be changed by an administrator via the User Administration panel.</p>\n<h2 id=\"task-management\">Task Management</h2>\n<h3 id=\"q-can-i-reorder-my-tasks\">Q: Can I reorder my tasks?</h3>\n<p>A: Yes, you can use the drag handle on the left side of each task card to reorder them manually. Note that manual reordering is disabled when a status filter is active.</p>\n<h3 id=\"q-what-do-the-different-task-priorities-mean\">Q: What do the different task priorities mean?</h3>\n<p>A:\n- <strong>High</strong>: Urgent tasks that should be addressed immediately.\n- <strong>Medium</strong>: Important tasks that should be completed soon.\n- <strong>Low</strong>: Non-urgent tasks.</p>\n<h2 id=\"troubleshooting\">Troubleshooting</h2>\n<h3 id=\"q-the-application-is-not-loading-what-should-i-do\">Q: The application is not loading. What should I do?</h3>\n<p>A: Ensure that both the backend and frontend services are running. If you are using Docker, run <code>docker compose up</code> to start all services.</p>\n<h3 id=\"q-i-am-getting-an-access-denied-error\">Q: I am getting an \"Access Denied\" error.</h3>\n<p>A: This error occurs if you try to access a page for which you do not have the required permissions (e.g., trying to access User Administration as a regular user).</p>",
  "android-build-instructions": "<h1 id=\"android-build-instructions\">Android Build Instructions</h1>\n<p>This document provides instructions on how to build and run the Android frontend of the AngularAI application locally.</p>\n<h2 id=\"prerequisites\">Prerequisites</h2>\n<ol>\n<li><strong>Android Studio</strong>: It is highly recommended to use the latest version of <a href=\"https://developer.android.com/studio\">Android Studio</a>.</li>\n<li><strong>JDK 17</strong>: The project is configured to use Java 17.</li>\n<li><strong>Android SDK</strong>: Ensure you have Android SDK 34 (UpsideDownCake) installed.</li>\n</ol>\n<h2 id=\"building-with-android-studio-recommended\">Building with Android Studio (Recommended)</h2>\n<ol>\n<li>Open Android Studio.</li>\n<li>Select <strong>Open</strong> and navigate to the <code>android/</code> directory in the project root.</li>\n<li>Wait for Android Studio to import the project and sync with Gradle.</li>\n<li>Once the sync is complete, you can build the project by going to <strong>Build &gt; Make Project</strong>.</li>\n<li>To run the app, select a device (emulator or physical device) and click the <strong>Run</strong> (green play) icon.</li>\n</ol>\n<h2 id=\"building-with-command-line\">Building with Command Line</h2>\n<p>If you have Gradle installed on your machine, you can build the APK from the terminal:</p>\n<ol>\n<li>Open a terminal and navigate to the <code>android/</code> directory.</li>\n<li>Run the following command to build the debug APK:\n    <code>bash\n    gradle assembleDebug</code></li>\n<li>The generated APK will be located at <code>android/app/build/outputs/apk/debug/app-debug.apk</code>.</li>\n</ol>\n<p><em>Note: If you don't have the Gradle wrapper files, opening the project in Android Studio for the first time will generate them for you.</em></p>\n<h2 id=\"connecting-to-the-backend\">Connecting to the Backend</h2>\n<p>The Android app needs to communicate with the Spring Boot backend. </p>\n<h3 id=\"emulator-10022\">Emulator (10.0.2.2)</h3>\n<p>If you are running the backend on <code>localhost:8080</code> and using the <strong>Android Emulator</strong>, the app is already configured to use <code>10.0.2.2:8080</code>, which is the special alias to your host loopback interface.</p>\n<h3 id=\"physical-device\">Physical Device</h3>\n<p>If you are using a <strong>physical device</strong>, you must ensure both the device and your computer are on the same Wi-Fi network.\n1.  Find your computer's local IP address (e.g., <code>192.168.1.15</code>).\n2.  Update the <code>baseUrl</code> in <code>android/app/src/main/java/ch/goodone/angularai/android/di/NetworkModule.kt</code> to point to your computer's IP:\n    <code>kotlin\n    .baseUrl(\"http://192.168.1.15:8080/\")</code>\n3.  Ensure the backend's <code>SecurityConfig.java</code> allows CORS from your device's IP (it is currently configured to allow <code>192.168.*</code>).</p>\n<h2 id=\"troubleshooting\">Troubleshooting</h2>\n<ul>\n<li><strong>Gradle Sync Fails</strong>: Ensure you have an active internet connection to download dependencies.</li>\n<li><strong>JDK Version</strong>: If you get a \"class file has wrong version\" error, make sure Android Studio is configured to use JDK 17 in <strong>Settings &gt; Build, Execution, Deployment &gt; Build Tools &gt; Gradle</strong>.</li>\n<li><strong>CORS Issues</strong>: Check the backend logs to see if requests from the mobile device are being rejected.</li>\n</ul>",
  "aws-setup": "<p>To run your AngularAI application on AWS using the existing Docker containers, I recommend the following architecture and steps.</p>\n<h3 id=\"recommended-database-provider-aws-rds\">Recommended Database Provider: AWS RDS</h3>\n<p>For a Spring Boot application using JPA/Hibernate, <strong>AWS RDS (Relational Database Service)</strong> is the highly recommended choice.\n*   <strong>Engine</strong>: <strong>PostgreSQL</strong> or <strong>MySQL</strong>. Given the project's current H2 configuration, either will work seamlessly with Spring Boot. PostgreSQL is generally preferred for modern enterprise applications.\n*   <strong>Why</strong>: It provides managed backups, patching, and high availability without the overhead of managing a database server yourself.</p>\n<hr />\n<h3 id=\"deployment-steps-on-aws\">Deployment Steps on AWS</h3>\n<h4 id=\"1-prepare-docker-images-for-aws\">1. Prepare Docker Images for AWS</h4>\n<p>You need to host your Docker images in a private registry.\n*   <strong>AWS Service</strong>: <strong>Amazon ECR (Elastic Container Registry)</strong>.\n*   <strong>Steps</strong>:\n    1. Create two ECR repositories: <code>angularai-frontend</code> and <code>angularai-backend</code>.\n    2. Authenticate your local Docker CLI to ECR.\n    3. Tag your local images with the ECR repository URLs.\n    4. Push the images: <code>docker push &lt;aws_account_id&gt;.dkr.ecr.eu-central-1.amazonaws.com/angularai-backend</code>.</p>\n<h4 id=\"2-set-up-the-database\">2. Set Up the Database</h4>\n<ul>\n<li><strong>AWS Service</strong>: <strong>Amazon RDS</strong>.</li>\n<li><strong>Steps</strong>:<ol>\n<li>Create a DB Instance (e.g., PostgreSQL).</li>\n<li>Configure a Security Group to allow traffic on the DB port (5432 for Postgres) only from the application's future Security Group.</li>\n<li>Note the endpoint, database name, username, and password.</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"3-configure-the-network-infrastructure\">3. Configure the Network Infrastructure</h4>\n<ul>\n<li><strong>AWS Service</strong>: <strong>VPC (Virtual Private Cloud)</strong>.</li>\n<li><strong>Steps</strong>:<ol>\n<li>Use a VPC with public and private subnets.</li>\n<li>Create an <strong>Application Load Balancer (ALB)</strong> to handle incoming web traffic.</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"4-deploy-containers\">4. Deploy Containers</h4>\n<ul>\n<li><strong>AWS Service</strong>: <strong>Amazon ECS (Elastic Container Service) with Fargate</strong>.</li>\n<li><strong>Why Fargate</strong>: It's \"serverless\" for containers—you don't have to manage the underlying EC2 instances.</li>\n<li><strong>Steps</strong>:<ol>\n<li><strong>Define Task Definitions</strong>:<ul>\n<li><strong>Backend Task</strong>: Add the backend image URL. Set environment variables to override <code>application.properties</code> (e.g., <code>SPRING_DATASOURCE_URL=jdbc:postgresql://&lt;rds-endpoint&gt;:5432/dbname</code>, <code>SPRING_DATASOURCE_USERNAME</code>, <code>SPRING_DATASOURCE_PASSWORD</code>).</li>\n<li><strong>Frontend Task</strong>: Add the frontend image URL.</li>\n</ul>\n</li>\n<li><strong>Create ECS Cluster</strong>: A logical grouping for your services.</li>\n<li><strong>Create ECS Services</strong>:<ul>\n<li><strong>Backend Service</strong>: Run the backend task. Connect it to a Target Group on the ALB (e.g., path <code>/api/*</code>).</li>\n<li><strong>Frontend Service</strong>: Run the frontend task. Connect it to the default Target Group on the ALB (path <code>/</code>).</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"5-domain-and-ssl-optional-but-recommended\">5. Domain and SSL (Optional but Recommended)</h4>\n<ul>\n<li><strong>AWS Services</strong>: <strong>Route 53</strong> and <strong>AWS Certificate Manager (ACM)</strong>.</li>\n<li><strong>Steps</strong>:<ol>\n<li>Provision an SSL certificate in ACM.</li>\n<li>Attach the certificate to the ALB listener (Port 443).</li>\n<li>Point your domain (Route 53) to the ALB's DNS name.</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"summary-of-recommended-stack\">Summary of Recommended Stack</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">Component</th>\n<th style=\"text-align: left;\">AWS Service</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>Frontend</strong></td>\n<td style=\"text-align: left;\">ECS Fargate (Nginx container)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Backend</strong></td>\n<td style=\"text-align: left;\">ECS Fargate (Spring Boot container)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Database</strong></td>\n<td style=\"text-align: left;\">RDS (PostgreSQL)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Registry</strong></td>\n<td style=\"text-align: left;\">ECR</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Routing</strong></td>\n<td style=\"text-align: left;\">Application Load Balancer</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Networking</strong></td>\n<td style=\"text-align: left;\">VPC</td>\n</tr>\n</tbody>\n</table>",
  "postgres-setup": "<p>I have added the PostgreSQL configuration to the project. This includes the necessary driver dependency and a dedicated properties file.</p>\n<h3 id=\"1-new-configuration-file\">1. New Configuration File</h3>\n<p>An additional configuration file has been created at:\n<code>backend/src/main/resources/application-postgres.properties</code></p>\n<p>This file is configured to connect to a local PostgreSQL instance:\n*   <strong>URL</strong>: <code>jdbc:postgresql://localhost:5432/angularai</code>\n*   <strong>Username/Password</strong>: <code>postgres</code> / <code>postgres</code> (Default)\n*   <strong>DDL Auto</strong>: <code>update</code> (Automatically manages the schema)</p>\n<p>To use this configuration when starting the application, you can set the active profile:\n*   <strong>Via IntelliJ</strong>: Add <code>-Dspring.profiles.active=postgres</code> to the VM options.\n*   <strong>Via CLI</strong>: <code>java -jar app.jar --spring.profiles.active=postgres</code></p>\n<h3 id=\"2-postgresql-setup-instructions\">2. PostgreSQL Setup Instructions</h3>\n<p>Follow these steps to prepare your local PostgreSQL database:</p>\n<h4 id=\"step-a-install-postgresql\">Step A: Install PostgreSQL</h4>\n<p>Ensure PostgreSQL is installed and running on your system. You can download it from <a href=\"https://www.postgresql.org/download/\">postgresql.org</a>.</p>\n<h4 id=\"step-b-create-the-database\">Step B: Create the Database</h4>\n<p>Open your terminal or a tool like <code>pgAdmin</code> or <code>psql</code> and execute the following commands:</p>\n<pre><code class=\"language-sql\">-- Connect as the default postgres user\n-- Create the database used in the properties file\nCREATE DATABASE angularai;\n</code></pre>\n<h4 id=\"step-c-database-schema-initialization\">Step C: Database Schema Initialization</h4>\n<p>You do <strong>not</strong> need to manually create tables or the schema. \nThe application is configured with <code>spring.jpa.hibernate.ddl-auto=update</code>. When you start the Spring Boot application with the <code>postgres</code> profile active:\n1.  Hibernate will connect to the <code>angularai</code> database.\n2.  It will automatically detect the entities (<code>User</code>, <code>Task</code>) defined in the code.\n3.  It will create the corresponding tables (<code>users</code>, <code>tasks</code>) and constraints (unique emails, etc.) if they do not exist.</p>\n<h3 id=\"3-project-updates\">3. Project Updates</h3>\n<ul>\n<li>Updated <code>backend/pom.xml</code> to include the <code>org.postgresql:postgresql</code> runtime dependency.</li>\n<li>The <code>DataInitializer</code> remains active and will populate your local PostgreSQL database with sample admin and user accounts upon the first successful startup.</li>\n</ul>",
  "aws-fargate-config": "<p>I have created the AWS ECS Fargate Task Definition configuration files for both the frontend and backend. These files define how your containers should run on AWS, including their resource requirements, networking, and environment variables.</p>\n<p>The files are located in the new <code>deploy/aws/</code> directory:</p>\n<h3 id=\"1-backend-task-definition\">1. Backend Task Definition</h3>\n<p><strong>File</strong>: <code>deploy/aws/backend-task-definition.json</code>\n*   <strong>CPU/Memory</strong>: 256 CPU units, 512 MiB Memory.\n*   <strong>Port</strong>: 8080.\n*   <strong>Configuration</strong>: Includes environment variable placeholders for connecting to your AWS RDS PostgreSQL database (<code>SPRING_DATASOURCE_URL</code>, etc.).\n*   <strong>Profile</strong>: Automatically activates the <code>postgres</code> profile.</p>\n<h3 id=\"2-frontend-task-definition\">2. Frontend Task Definition</h3>\n<p><strong>File</strong>: <code>deploy/aws/frontend-task-definition.json</code>\n*   <strong>CPU/Memory</strong>: 256 CPU units, 512 MiB Memory.\n*   <strong>Port</strong>: 80 (Nginx).\n*   <strong>Logging</strong>: Configured to send logs to CloudWatch.</p>\n<hr />\n<h3 id=\"how-to-use-these-files\">How to use these files</h3>\n<h4 id=\"a-prerequisites\">A. Prerequisites</h4>\n<ol>\n<li><strong>ECR Repositories</strong>: Ensure you have pushed your Docker images to Amazon ECR.</li>\n<li><strong>IAM Role</strong>: Ensure the <code>ecsTaskExecutionRole</code> exists in your AWS account (standard role created by AWS).</li>\n<li>\n<p><strong>CloudWatch Log Groups</strong>: You must manually create the Log Groups in CloudWatch for both services to prevent a <code>ResourceInitializationError</code> at startup:</p>\n<ul>\n<li><code>/ecs/angularai-frontend</code></li>\n<li><code>/ecs/angularai-backend</code></li>\n<li><code>/ecs/angularai-backend-test</code> (if using the test definition)</li>\n</ul>\n<p>You can create them via the AWS Console or CLI:\n<code>bash\naws logs create-log-group --log-group-name /ecs/angularai-frontend\naws logs create-log-group --log-group-name /ecs/angularai-backend\naws logs create-log-group --log-group-name /ecs/angularai-backend-test</code>\n4.  <strong>RDS Database</strong>: Your PostgreSQL database should be running and accessible (Only required for <code>backend-task-definition.json</code>).</p>\n</li>\n</ol>\n<h4 id=\"b-registering-tasks-via-cli\">B. Registering Tasks via CLI</h4>\n<p><strong>CRITICAL</strong>: You must manually edit the <code>.json</code> files in <code>deploy/aws/</code> and replace all placeholders enclosed in angle brackets (e.g., <code>&lt;AWS_ACCOUNT_ID&gt;</code>, <code>&lt;REGION&gt;</code>, <code>&lt;RDS_ENDPOINT&gt;</code>) with your actual AWS values. </p>\n<p>Failure to replace <code>&lt;AWS_ACCOUNT_ID&gt;</code> in the <code>executionRoleArn</code> and <code>taskRoleArn</code> fields will result in a <code>ClientException: Role is not valid</code> error.</p>\n<p>Once edited, you can register these task definitions using the AWS CLI:</p>\n<pre><code class=\"language-bash\"># Register Backend\naws ecs register-task-definition --cli-input-json file://deploy/aws/backend-task-definition.json\n\n# Register Test Backend\naws ecs register-task-definition --cli-input-json file://deploy/aws/backend-test-task-definition.json\n\n# Register Frontend\naws ecs register-task-definition --cli-input-json file://deploy/aws/frontend-task-definition.json\n</code></pre>\n<h4 id=\"c-final-deployment\">C. Final Deployment</h4>\n<ol>\n<li><strong>Cluster</strong>: Create an ECS Cluster (Fargate type).</li>\n<li><strong>Services</strong>: Create two ECS Services (one for frontend, one for backend) using the registered task definitions.</li>\n<li><strong>Networking</strong>:<ul>\n<li>The <strong>Backend Service</strong> should be in a private subnet.</li>\n<li>The <strong>Frontend Service</strong> should be associated with an Application Load Balancer (ALB) to be accessible from the internet.</li>\n<li>The ALB should route <code>/api/*</code> requests to the Backend Service and all other requests to the Frontend Service.</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p><strong>Note</strong>: Remember to replace the placeholders in the JSON files (like <code>&lt;AWS_ACCOUNT_ID&gt;</code>, <code>&lt;REGION&gt;</code>, <code>&lt;RDS_ENDPOINT&gt;</code>, etc.) with your actual AWS resource details before registering.</p>\n</blockquote>",
  "aws-create-target-group": "<h1 id=\"creating-an-aws-target-group-for-the-backend\">Creating an AWS Target Group for the Backend</h1>\n<p>This guide explains how to create a Target Group for your Spring Boot backend and associate it with your ECS Fargate service when using a shared Application Load Balancer (ALB).</p>\n<h3 id=\"1-create-the-target-group\">1. Create the Target Group</h3>\n<ol>\n<li>Open the <strong>EC2 Console</strong> and navigate to <strong>Target Groups</strong> (under <em>Load Balancing</em>).</li>\n<li>Click <strong>Create target group</strong>.</li>\n<li><strong>Basic configuration</strong>:<ul>\n<li><strong>Target type</strong>: Select <strong>IP addresses</strong> (Required for Fargate).</li>\n<li><strong>Target group name</strong>: Enter <code>angularai-backend-tg</code>.</li>\n<li><strong>Protocol</strong>: <code>HTTP</code>.</li>\n<li><strong>Port</strong>: <code>8080</code>.</li>\n<li><strong>VPC</strong>: Select the same VPC where your ALB and ECS cluster reside.</li>\n<li><strong>Protocol version</strong>: <code>HTTP1</code>.</li>\n</ul>\n</li>\n<li><strong>Health checks</strong>:<ul>\n<li><strong>Health check protocol</strong>: <code>HTTP</code>.</li>\n<li><strong>Health check path</strong>: <code>/api/auth/login</code> (or <code>/api/tasks</code> - it just needs to respond, even if it's 401 or 405).</li>\n<li><em>Advanced health check settings</em>:<ul>\n<li><strong>Healthy threshold</strong>: <code>2</code>.</li>\n<li><strong>Unhealthy threshold</strong>: <code>3</code>.</li>\n<li><strong>Timeout</strong>: <code>5 seconds</code>.</li>\n<li><strong>Interval</strong>: <code>30 seconds</code>.</li>\n<li><strong>Success codes</strong>: <code>200-499</code> (This ensures that even a 401 Unauthorized or 405 Method Not Allowed counts as \"healthy\" for the ALB).</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Click <strong>Next</strong>.</li>\n<li><strong>Register targets</strong>:<ul>\n<li><strong>Do NOT</strong> manually register any IPs here. ECS will automatically manage the IP addresses of your tasks.</li>\n</ul>\n</li>\n<li>Click <strong>Create target group</strong>.</li>\n</ol>\n<h3 id=\"2-associate-target-group-with-ecs-service\">2. Associate Target Group with ECS Service</h3>\n<p>If you have already created the service without a load balancer, you cannot add one after the service is created. You must <strong>recreate</strong> the service or update it if it was already configured with a placeholder.</p>\n<p><strong>To Recreate/Update the Service</strong>:\n1.  Go to the <strong>ECS Console</strong> -&gt; <strong>Clusters</strong> -&gt; your cluster.\n2.  Select the <strong>backend-service</strong> and click <strong>Delete</strong> (or create a new one with a different name).\n3.  Click <strong>Create</strong> to start the service creation wizard again.\n4.  In the <strong>Load balancing</strong> section:\n    *   <strong>Load balancer type</strong>: Application Load Balancer.\n    *   <strong>Load balancer</strong>: Select your existing frontend ALB.\n    *   <strong>Container to load balance</strong>: <code>backend 8080:8080</code>.\n    *   <strong>Target group</strong>: Select <strong>Use an existing target group</strong> and pick <code>angularai-backend-tg</code>.\n5.  Complete the service creation.</p>\n<h3 id=\"3-update-alb-listener-rules\">3. Update ALB Listener Rules</h3>\n<ol>\n<li>Go to <strong>Load Balancers</strong> in the EC2 Console.</li>\n<li>Select your shared ALB.</li>\n<li>Go to the <strong>Listeners</strong> tab and select your listener (Port 80).</li>\n<li>Click <strong>View/edit rules</strong>.</li>\n<li>Click the <strong>+</strong> (Add rules) icon and then <strong>Insert Rule</strong>.</li>\n<li><strong>IF</strong>: Path is <code>/api/*</code>.</li>\n<li><strong>THEN</strong>: Forward to <code>angularai-backend-tg</code>.</li>\n<li>Ensure this rule is <strong>above</strong> the default rule (which should point to the frontend).</li>\n<li>Click <strong>Save</strong>.</li>\n</ol>\n<h3 id=\"4-verification\">4. Verification</h3>\n<ol>\n<li>Wait for the ECS task to reach the <code>RUNNING</code> state.</li>\n<li>Check the <strong>Target Group</strong> -&gt; <strong>Targets</strong> tab. The health status should eventually become <strong>Healthy</strong>.</li>\n<li>Access the application via the ALB DNS name. The frontend should now be able to communicate with the backend via the <code>/api</code> path.</li>\n</ol>",
  "aws-alb-troubleshooting": "<h1 id=\"alb-and-frontend-backend-connectivity-troubleshooting\">ALB and Frontend-Backend Connectivity Troubleshooting</h1>\n<p>This document explains how to verify and fix the connectivity between your Angular frontend and Spring Boot backend when running on AWS ECS Fargate.</p>\n<h3 id=\"1-improved-error-messages\">1. Improved Error Messages</h3>\n<p>The <code>LoginComponent</code> now displays specific error messages to help you distinguish between authentication failures and infrastructure issues:\n- <strong>\"Invalid login or password\"</strong>: This is a <code>401 Unauthorized</code> response. The ALB correctly reached the backend, but the credentials were rejected.\n- <strong>\"An error occurred: Not Found\"</strong>: This is a <code>404 Not Found</code>. This usually happens if the ALB HTTPS listener is missing the <code>/api/*</code> rule and is forwarding the request to the frontend container (Nginx) instead of the backend.\n- <strong>\"An error occurred: Bad Gateway\"</strong>: This is a <code>502 Bad Gateway</code>. This can happen for two reasons:\n    - <strong>Missing ALB Rule</strong>: The ALB forwarded the request to the Frontend (Nginx), but Nginx could not reach the backend (e.g., in AWS, the \"backend\" hostname doesn't exist). Look for <code>backend could not be resolved</code> in the frontend logs.\n    - <strong>Backend Down</strong>: The ALB is trying to reach the backend, but the backend is either down or its security group is blocking the ALB.</p>\n<h3 id=\"2-the-single-alb-strategy\">2. The \"Single ALB\" Strategy</h3>\n<p>Based on your report, you have two different Load Balancer URLs:\n- <code>angular-boot-lb-frontend-...</code>\n- <code>angular-boot-lb-backend-...</code></p>\n<p><strong>This is likely the cause of the issue.</strong> In a standard production setup (and as configured in our <code>nginx.conf</code>), the frontend and backend should share <strong>ONE</strong> Application Load Balancer. </p>\n<p>The frontend sends requests to <code>/api/...</code>. If the frontend is on one domain and the backend is on another, the browser will block the requests due to <strong>CORS</strong> (Cross-Origin Resource Sharing) or the frontend will try to reach <code>/api</code> on the <em>frontend's</em> load balancer, which doesn't know about the backend.</p>\n<h3 id=\"2-how-to-verify-alb-routing-rules\">2. How to Verify ALB Routing Rules</h3>\n<p>To verify that your ALB is correctly routing <code>/api/*</code> to the backend and everything else to the frontend, follow these steps in the AWS Console:</p>\n<ol>\n<li>Open the <strong>EC2 Console</strong> and go to <strong>Load Balancers</strong>.</li>\n<li>Select the <strong>Load Balancer</strong> you are using for the <strong>Frontend</strong>.</li>\n<li>Click on the <strong>Listeners</strong> tab.</li>\n<li>Select the listener (usually <strong>HTTP:80</strong> or <strong>HTTPS:443</strong>).</li>\n<li>Click <strong>View/edit rules</strong>.</li>\n<li>You should see at least two rules:<ul>\n<li><strong>Rule 1</strong>: IF <code>Path is /api/*</code> THEN <code>Forward to target group: angularai-backend-tg</code>.</li>\n<li><strong>Last (Default) Rule</strong>: IF <code>Requests otherwise not routed</code> THEN <code>Forward to target group: angularai-frontend-tg</code>.</li>\n</ul>\n</li>\n</ol>\n<p>⚠️ <strong>Note for HTTPS Users</strong>: If you have enabled HTTPS, you must perform these steps for <strong>BOTH</strong> the HTTP (80) and HTTPS (443) listeners.</p>\n<p><strong>If Rule 1 or the Target Group is missing:</strong>\n- Follow the <a href=\"aws_create_target_group.md\">Creating a Backend Target Group</a> guide to create the group and add the rule.</p>\n<h3 id=\"3-verify-target-group-health\">3. Verify Target Group Health</h3>\n<p>If the routing rules are correct but you still get a <code>502 Bad Gateway</code> or <code>504 Gateway Timeout</code>:</p>\n<ol>\n<li>Go to <strong>Target Groups</strong> in the EC2 Console.</li>\n<li>Select your <strong>Backend Target Group</strong>.</li>\n<li>Click the <strong>Targets</strong> tab.</li>\n<li>Check the <strong>Health status</strong>:<ul>\n<li>If it's <strong>Unhealthy</strong>: The ALB cannot reach your Spring Boot container.</li>\n<li><strong>Common Fix</strong>: Ensure the health check path is set to an endpoint that exists (e.g., <code>/api/auth/login</code> or just <code>/api/tasks</code> if they return 401/405, or create a <code>/actuator/health</code> endpoint).</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-security-group-chaining\">4. Security Group Chaining</h3>\n<p>Ensure the network traffic can flow:</p>\n<ol>\n<li><strong>ALB Security Group</strong>: Must allow Inbound <code>80/443</code> from <code>0.0.0.0/0</code>.</li>\n<li><strong>Backend Service Security Group</strong>:<ul>\n<li>Must allow Inbound <code>8080</code> from the <strong>Security Group ID of the ALB</strong>.</li>\n<li>Do <strong>not</strong> use <code>0.0.0.0/0</code> here; specifically allow the ALB's SG to ensure only the load balancer can talk to the backend.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-frontend-service-configuration\">5. Frontend Service Configuration</h3>\n<p>Ensure your <code>frontend/nginx.conf</code> is using the correct service name if you are using Docker Compose, but on AWS, the ALB handles the routing. The frontend code uses relative paths like <code>/api/auth/login</code>, so it will automatically use the same host as the frontend.</p>\n<p><strong>To fix your current state:</strong>\n1.  Choose one ALB (the frontend one).\n2.  Add the <code>/api/*</code> rule to its listener pointing to the backend target group.\n3.  Update your frontend to point only to that single ALB URL.</p>",
  "aws-ecs-push-instructions": "<h1 id=\"instructions-for-creating-and-pushing-docker-images-to-amazon-ecr\">Instructions for Creating and Pushing Docker Images to Amazon ECR</h1>\n<p>This guide provides step-by-step instructions on how to build your AngularAI Docker images and push them to Amazon Elastic Container Registry (ECR).</p>\n<h2 id=\"prerequisites\">Prerequisites</h2>\n<ol>\n<li><strong>AWS CLI Installed</strong>: Ensure the <a href=\"https://aws.amazon.com/cli/\">AWS CLI</a> is installed and configured with your credentials.</li>\n<li><strong>Docker Installed</strong>: Ensure Docker is running on your machine.</li>\n<li><strong>AWS Permissions</strong>: Your AWS user/role must have permissions to create ECR repositories and push images (<code>AmazonEC2ContainerRegistryFullAccess</code> or similar).</li>\n</ol>\n<hr />\n<h2 id=\"step-1-authenticate-docker-to-ecr\">Step 1: Authenticate Docker to ECR</h2>\n<p>Before pushing, you must authenticate your Docker client to your AWS registry. Replace <code>&lt;REGION&gt;</code> with your AWS region (e.g., <code>us-east-1</code>) and <code>&lt;AWS_ACCOUNT_ID&gt;</code> with your 12-digit account ID.</p>\n<pre><code class=\"language-bash\">aws ecr get-login-password --region eu-central-1 | docker login --username AWS --password-stdin 426141506813.dkr.ecr.eu-central-1.amazonaws.com\n---\n\n## Step 2: Create ECR Repositories\n\nIf you haven't already created the repositories in the AWS Console, you can do it via the CLI:\n\n```bash\n# Create Backend Repository\naws ecr create-repository --repository-name angularai-backend --region eu-central-1\n\n# Create Frontend Repository\naws ecr create-repository --repository-name angularai-frontend --region eu-central-1\n</code></pre>\n<hr />\n<h2 id=\"step-3-build-and-tag-docker-images\">Step 3: Build and Tag Docker Images</h2>\n<p>Navigate to the project root directory.</p>\n<h3 id=\"31-backend-image\">3.1 Backend Image</h3>\n<pre><code class=\"language-bash\"># Build the image\ndocker build -t angularai-backend -f backend/Dockerfile .\n\n# Tag for ECR\ndocker tag angularai-backend:latest 426141506813.dkr.ecr.eu-central-1.amazonaws.com/angularai-backend:latest\n</code></pre>\n<h3 id=\"32-frontend-image\">3.2 Frontend Image</h3>\n<pre><code class=\"language-bash\"># Build the image\ndocker build -t angularai-frontend -f frontend/Dockerfile .\n\n# Tag for ECR\ndocker tag angularai-frontend:latest 426141506813.dkr.ecr.eu-central-1.amazonaws.com/angularai-frontend:latest\n</code></pre>\n<hr />\n<h2 id=\"step-4-push-images-to-ecr\">Step 4: Push Images to ECR</h2>\n<p>Now push the tagged images to your AWS registry.</p>\n<pre><code class=\"language-bash\"># Push Backend\ndocker push 426141506813.dkr.ecr.eu-central-1.amazonaws.com/angularai-backend:latest\n\n# Push Frontend\ndocker push 426141506813.dkr.ecr.eu-central-1.amazonaws.com/angularai-frontend:latest\n</code></pre>\n<hr />\n<h2 id=\"summary-of-urls\">Summary of URLs</h2>\n<p>After pushing, your image URLs will follow this pattern:\n- <strong>Backend</strong>: <code>426141506813.dkr.ecr.eu-central-1.amazonaws.com/angularai-backend:latest</code>\n- <strong>Frontend</strong>: <code>426141506813.dkr.ecr.eu-central-1.amazonaws.com/angularai-frontend:latest</code></p>\n<p>Use these URLs in your <strong>ECS Task Definitions</strong> (e.g., in <code>deploy/aws/backend-task-definition.json</code> and <code>deploy/aws/frontend-task-definition.json</code>).</p>",
  "md-to-confluence": "<pre><code class=\"language-python\">import markdown\nimport requests\nimport json\nimport os\n\n# Configuration\nCONFLUENCE_URL = &quot;https://your-domain.atlassian.net/wiki/rest/api/content&quot;\nUSERNAME = &quot;your-email@example.com&quot;\nAPI_TOKEN = &quot;your-api-token&quot;\nSPACE_KEY = &quot;DOC&quot;\nPARENT_PAGE_ID = &quot;12345&quot; # Optional: ID of the parent page\n\ndef md_to_confluence_storage(md_file_path):\n    &quot;&quot;&quot;\n    Converts a Markdown file to HTML which is compatible with Confluence Storage Format.\n    Note: Standard HTML is often accepted by Confluence API, but some macros might need special tags.\n    &quot;&quot;&quot;\n    with open(md_file_path, 'r', encoding='utf-8') as f:\n        md_content = f.read()\n\n    # Convert Markdown to HTML\n    html_content = markdown.markdown(md_content, extensions=['extra', 'toc'])\n    return html_content\n\ndef post_to_confluence(title, html_content, page_id=None):\n    &quot;&quot;&quot;\n    Posts content to Confluence. If page_id is provided, it updates the page.\n    &quot;&quot;&quot;\n    headers = {\n        &quot;Accept&quot;: &quot;application/json&quot;,\n        &quot;Content-Type&quot;: &quot;application/json&quot;\n    }\n\n    auth = (USERNAME, API_TOKEN)\n\n    data = {\n        &quot;type&quot;: &quot;page&quot;,\n        &quot;title&quot;: title,\n        &quot;space&quot;: {&quot;key&quot;: SPACE_KEY},\n        &quot;body&quot;: {\n            &quot;storage&quot;: {\n                &quot;value&quot;: html_content,\n                &quot;representation&quot;: &quot;storage&quot;\n            }\n        }\n    }\n\n    if PARENT_PAGE_ID:\n        data[&quot;ancestors&quot;] = [{&quot;id&quot;: PARENT_PAGE_ID}]\n\n    if page_id:\n        # Update existing page (needs version increment)\n        # First, get current version\n        resp = requests.get(f&quot;{CONFLUENCE_URL}/{page_id}?expand=version&quot;, auth=auth)\n        version = resp.json()['version']['number'] + 1\n        data[&quot;version&quot;] = {&quot;number&quot;: version}\n        url = f&quot;{CONFLUENCE_URL}/{page_id}&quot;\n        response = requests.put(url, data=json.dumps(data), headers=headers, auth=auth)\n    else:\n        # Create new page\n        url = CONFLUENCE_URL\n        response = requests.post(url, data=json.dumps(data), headers=headers, auth=auth)\n\n    return response.status_code, response.text\n\nif __name__ == &quot;__main__&quot;:\n    docs = [\n        (&quot;User Guide&quot;, &quot;doc/userguide/user-guide.md&quot;),\n        (&quot;Admin Guide&quot;, &quot;doc/userguide/admin-guide.md&quot;),\n        (&quot;FAQ&quot;, &quot;doc/userguide/faq.md&quot;)\n    ]\n\n    print(&quot;This script is a proposal. Please configure your Confluence credentials before running.&quot;)\n    # for title, path in docs:\n    #     if os.path.exists(path):\n    #         print(f&quot;Converting {path}...&quot;)\n    #         storage_format = md_to_confluence_storage(path)\n    #         # status, text = post_to_confluence(title, storage_format)\n    #         # print(f&quot;Status: {status}&quot;)\n\n</code></pre>"
}